const std = @import("std");
const lexer = @import("../../lexer/lexer.zig");
const tokenizer = @import("../../tokenizer/tokenizer.zig");
const Errors = @import("../x86_64Generator.zig").Errors;
const GeneratorErrors = @import("../x86_64Generator.zig").GeneratorErrors;
const cpu = @import("../../cpu/cpu.zig");
const utils = @import("../utils.zig");
const generator = @import("../x86_64Generator.zig");
const Self = generator.x86_64Generator.Self;

/// We'll pad unknown jump instructions with this number of NOPs
/// In our second pass we'll come through and adjust the jump instruction to the worst possible size
/// to support jumping to the target.
/// Wut? By assumping the worst possible jump distance in the first pass all jump statements are as
/// far away from each other as they can get. Any updates to reduce the distance will thus not
/// require any added bytes - so we only ever need to remove bytes. In the second pass we can then
/// start from the first pending jump, update the instruction size to handle the real worst case to
/// the target (instead of this value), and then decrement all symbol locations afterwards with the
/// reduced amount.
/// Worst case this means we might still use too large of an instruction if decrementing a symbol
/// location would put it in range of a smaller instruction jump. But there's a relatively low chance
/// of it happening as the jump distance will have to be on the border of 1-2 bytes, or 2-4 bytes.
/// |JMP B
/// |     \_____
/// |           \
/// |XXXXXXXXXXXXY
/// |A           B
/// A is at 0, B is at 12, thus the jump _could_ just use a single byte but it is initially padded
/// with 12 NOPs in the first pass and a pending jump of A -> B with a size of 12 is record.
/// After the first pass, the pending jump is evaluated and the worst jump size of 1-byte is
/// generated by finding the max byte count to hold (12 - 0) 12. The pending jump size is updated
/// to 1 byte and the address of any symbol >= the pending jump address + original size is
/// decremented by 12. This then produces:
/// |JMP B
/// |   _/
/// |  /
/// |XXY
/// |A B
const MaxJumpInstructionLength = 12;
const OpCode_Nop = 0x90;
const OpCode_Jmp_Relative_OneByte = 0xEB;
const OpCode_Jmp_Relative_TwoByte = 0xE9;
const OpCode_Jmp_Relative_FourByte = 0xE9;

pub fn emitJump(self: *Self, operand: lexer.Operand, location: tokenizer.Location) GeneratorErrors!void {
    var jumpTarget: ?isize = null;

    // Direct access using an identifier (label)
    if (operand.accessType == .direct and @as(lexer.ValueType, operand.value) == .identifier) {
        // Do we know about this label?
        if (self.getSymbol(operand.value.identifier)) |symbol| {
            // We found the label - check if there isn't a valid address
            if (symbol.address) |_| {} else {
                // No valid address so we don't know where to jump to
                std.log.debug("Found reference to symbol \"{s}\" with unknown address; tracking and nop'ing for now.", .{symbol.name});

                // Record the jump with the padded value
                try self.recordPendingJump(self.currentAddress(), symbol, MaxJumpInstructionLength, location);

                // Emit the padding in-place of the jump
                for (0..12) |_| try self.emitBytes(&[_]u8{OpCode_Nop});
                return;
            }

            // Set the jump target to the symbol's address
            jumpTarget = @as(isize, @intCast(symbol.address.?));
        } else {
            // No such label - record it with a null address
            std.log.debug("Found reference to unknown symbol \"{s}\"; storing and nop'ing for now.", .{operand.value.identifier});

            // Record the symbol with a null address
            var symbol = try self.putSymbol(operand.value.identifier, null, location);

            // Record the jump with the padded value
            try self.recordPendingJump(self.currentAddress(), symbol, MaxJumpInstructionLength, location);

            // Emit the padding in-place of the jump
            for (0..12) |_| try self.emitBytes(&[_]u8{OpCode_Nop});
            return;
        }
    }
    // Jump direct to a constant (memory location)
    else if (operand.accessType == .direct and @as(lexer.ValueType, operand.value) == .constant) {
        jumpTarget = operand.valueFromConstant(isize) catch {
            return self.createFormattedError(GeneratorErrors.InternalException, "Failed to parse jump target from \"{s}\".", .{operand.value.constant}, location);
        };
    }

    // Generate and emit the jump instruction
    var bytes = try allocJumpInstruction(
        self,
        // Shouldn't be possible
        jumpTarget orelse unreachable,
        location,
    );
    defer self.allocator.free(bytes);
    try self.emitBytes(bytes);
}

/// Handles generating a jump instruction's bytes as well as processes pending jumps that can be resolved.
pub fn allocJumpInstruction(self: *Self, target: isize, location: tokenizer.Location) GeneratorErrors![]const u8 {
    // Calculate the relative jump
    var jumpTarget = target;
    jumpTarget -= @intCast(self.addressOrigin + self.addressCounter + 1);

    // Determine the number of bytes the jump target requires
    var valueBytesCount: u8 = utils.requiredBytesForSignedInteger(jumpTarget);

    // Determine the number of bytes with padding we'll need
    // This is important if we hit the worst case where the instruction must include padding (see
    // above).
    var valueBytesCountWithJumps: u8 = valueBytesCount;
    // TODO: Probably not an O(n) lookup /sigh
    for (0..self.pendingJumps.items.len) |i| {
        // Find the pending jump corresponding to this jump
        var pendingJump = self.pendingJumps.items[i];
        if (pendingJump.address == self.currentAddress()) {
            // Update it's size and then remove it from the list as we've handled it
            valueBytesCountWithJumps = pendingJump.size;
            _ = self.pendingJumps.swapRemove(i);
            break;
        }
    }

    // If we're moving backwards we need to decrement our value byte count
    // Note: We don't decrement with the padding count because the instruction pointer is at the
    // end of the jmp instruction only, not at the end of the NOP pad
    if (jumpTarget < 0) {
        // Account for the value bytes
        jumpTarget -= valueBytesCount;
    }

    // The opcode for the instruction
    var opcode: u8 = switch (valueBytesCount) {
        // 1-Byte value
        1 => OpCode_Jmp_Relative_OneByte,
        // 2-Byte value
        2 => OpCode_Jmp_Relative_TwoByte,
        3, 4 => OpCode_Jmp_Relative_FourByte,
        // Long/Far jump
        else => unreachable,
    };

    // Generate the value buffer
    var valueBuffer = utils.allocBytesFromNumber(isize, valueBytesCount, jumpTarget, self.allocator) catch {
        return self.createFormattedError(GeneratorErrors.InternalException, "Failed to allocate space for jump target value buffer.", .{}, location);
    };

    // Generate a default/empty NOP buffer so we can be lazy and assume we always free this buffer
    var nopBuffer: []u8 = self.allocator.alloc(u8, 0) catch {
        return self.createFormattedError(GeneratorErrors.InternalException, "Failed to allocate space for jump target nop buffer.", .{}, location);
    };
    defer self.allocator.free(valueBuffer);

    // If we _need_ a NOP padding then re-generate the buffer
    if (valueBytesCountWithJumps != valueBytesCount) {
        // Free the default
        self.allocator.free(nopBuffer);
        nopBuffer = self.allocator.alloc(u8, valueBytesCountWithJumps - valueBytesCount) catch {
            return self.createFormattedError(GeneratorErrors.InternalException, "Failed to allocate space for jump target nop buffer.", .{}, location);
        };
        // Initialize the buffer with NOPs
        for (0..nopBuffer.len) |i| nopBuffer[i] = OpCode_Nop;
    }
    defer self.allocator.free(nopBuffer);

    var result = std.mem.concat(self.allocator, u8, &[_][]const u8{
        &[_]u8{opcode},
        valueBuffer,
        nopBuffer,
    }) catch {
        return self.createError(Errors.InternalException, "Failed to combine slices.", location);
    };
    return result;
}
